{"version":3,"file":"universal-router-sync.esm.min.js","sources":["../src/match-path.ts","../src/match-route.ts","../src/resolve-route.ts","../src/universal-router-sync.ts","../src/is-child-route.ts"],"sourcesContent":["/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp'; // keep require\nimport { MatchedKeys, MatchedPath, Params, Route } from './types';\n\ntype RegexpCache = {\n  keys: MatchedKeys;\n  pattern: RegExp;\n};\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst cache = new Map<string, RegexpCache>();\n\nfunction decodeParam(val: string): string {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nexport function matchPath<Context extends object, Result>(\n  route: Route<Context, Result>,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n): MatchedPath | null {\n  const end = !route.children;\n  const cacheKey = `${route.path || ''}|${end}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys: MatchedKeys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(route.path || '', keys, { end }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(pathname);\n  if (!m) {\n    return null;\n  }\n\n  const path: string = m[0];\n  const params: Params = { ...parentParams };\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,\n    keys: parentKeys.concat(regexp.keys),\n    params,\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { matchPath } from './match-path';\nimport { MatchedKeys, MatchedPath, MatchedRoute, Params, Route } from './types';\n\nexport function matchRoute<Context extends object, Result>(\n  route: Route<Context, Result>,\n  baseUrl: string,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n) {\n  let match: MatchedPath | null = null;\n  let childMatches: null | {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result>;\n  };\n  let childIndex = 0;\n\n  return {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result> {\n      if (route === routeToSkip) {\n        return { done: true, value: undefined };\n      }\n\n      if (!match) {\n        match = matchPath(route, pathname, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              baseUrl,\n              path: match.path,\n              keys: match.keys,\n              params: match.params,\n            },\n          };\n        }\n      }\n\n      if (match && route.children) {\n        while (childIndex < route.children.length) {\n          if (!childMatches) {\n            const childRoute = route.children[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + match.path,\n              pathname.substr(match.path.length),\n              match.keys,\n              match.params,\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true, value: undefined };\n    },\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { Params, ResultReturn, RouteContext } from './types';\n\nexport function resolveRoute<Context extends object, Result>(\n  context: RouteContext<Context, Result>,\n  params: Params,\n): ResultReturn<Result> {\n  if (typeof context.route.action === 'function') {\n    return context.route.action(context, params);\n  }\n\n  return undefined;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport { isChildRoute } from './is-child-route';\nimport { matchRoute } from './match-route';\nimport { resolveRoute } from './resolve-route';\nimport {\n  ErrorHandler,\n  MatchedRoute,\n  Options,\n  ResolveContext,\n  ResolveRoute,\n  ResultReturn,\n  Route,\n  RouteContext,\n  RouteOrRoutes,\n} from './types';\n\ntype RouterContext<Context extends object, Result> = Context & {\n  router: UniversalRouterSync<Context, Result>;\n};\n\nexport default class UniversalRouterSync<Context extends object, Result> {\n  static pathToRegexp = pathToRegexp;\n\n  baseUrl: string;\n  errorHandler?: ErrorHandler<Context, Result>;\n  resolveRoute: ResolveRoute<Context, Result>;\n  context: RouterContext<Context, Result>;\n  root: Route<Context, Result>;\n\n  constructor(\n    routes: RouteOrRoutes<Context, Result>,\n    options: Options<Context, Result> = { context: {} as Context },\n  ) {\n    if (!routes || typeof routes !== 'object') {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = { router: this, ...options.context } as RouterContext<Context, Result>;\n    this.root = Array.isArray(routes) ? { path: '', children: routes, parent: null } : routes;\n    this.root.parent = null;\n  }\n\n  resolve(pathnameOrContext: string | (ResolveContext & Context)): ResultReturn<Result> {\n    const context = {\n      ...this.context,\n      ...(typeof pathnameOrContext === 'string'\n        ? { pathname: pathnameOrContext }\n        : pathnameOrContext),\n    } as RouteContext<Context, Result>;\n    const match = matchRoute(\n      this.root,\n      this.baseUrl,\n      context.pathname.substr(this.baseUrl.length),\n      [],\n      null,\n    );\n    const resolve = this.resolveRoute;\n    let matches: MatchedRoute<Context, Result> | null = null;\n    let nextMatches: MatchedRoute<Context, Result> | null = null;\n    let currentContext = context;\n\n    function next(\n      resume?: boolean,\n      parent: Route<Context, Result> | null = matches && matches.value ? matches.value.route : null,\n      prevResult?: Result | null | undefined,\n    ): ResultReturn<Result> {\n      const lastRoute = matches && matches.value ? matches.value.route : null;\n      const routeToSkip = prevResult === null ? lastRoute : null;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n\n          return null;\n        }\n      }\n\n      if (matches.done) {\n        const error = new Error('Route not found');\n        (error as any).status = 404;\n        throw error;\n      }\n\n      currentContext = { ...context, ...matches.value };\n\n      const result = resolve(currentContext, matches.value.params);\n      if (result !== null && result !== undefined) {\n        return result;\n      }\n\n      return next(resume, parent, result);\n    }\n\n    context.next = next;\n\n    try {\n      return next(true, this.root);\n    } catch (error) {\n      if (this.errorHandler) {\n        return this.errorHandler(error, currentContext);\n      }\n      throw error;\n    }\n  }\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\ntype WithParent = {\n  parent?: WithParent | null | undefined;\n};\n\nexport function isChildRoute(\n  parentRoute: WithParent | null,\n  childRoute: WithParent | null | undefined,\n): boolean {\n  if (parentRoute === null) return false;\n\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":["hasOwnProperty","Object","prototype","cache","Map","decodeParam","val","decodeURIComponent","err","matchRoute","route","baseUrl","pathname","parentKeys","parentParams","childMatches","match","childIndex","[object Object]","routeToSkip","done","value","undefined","end","children","cacheKey","path","regexp","get","keys","pattern","pathToRegexp","set","m","exec","params","i","length","key","prop","name","call","repeat","split","delimiter","map","charAt","substr","concat","matchPath","childRoute","parent","childMatch","next","resolveRoute","context","action","UniversalRouterSync","routes","options","TypeError","this","errorHandler","router","root","Array","isArray","pathnameOrContext","resolve","matches","nextMatches","currentContext","resume","prevResult","lastRoute","parentRoute","isChildRoute","error","Error","status","result"],"mappings":"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"}