{"version":3,"file":"universal-router-sync.umd.min.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/path-to-regexp/index.js","../src/match-path.ts","../src/match-route.ts","../src/resolve-route.ts","../src/universal-router-sync.ts","../src/is-child-route.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp'; // keep require\nimport { MatchedKeys, MatchedPath, Params, Route } from './types';\n\ntype RegexpCache = {\n  keys: MatchedKeys;\n  pattern: RegExp;\n};\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst cache = new Map<string, RegexpCache>();\n\nfunction decodeParam(val: string): string {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nexport function matchPath<Context extends object, Result>(\n  route: Route<Context, Result>,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n): MatchedPath | null {\n  const end = !route.children;\n  const cacheKey = `${route.path || ''}|${end}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys: MatchedKeys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(route.path || '', keys, { end }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(pathname);\n  if (!m) {\n    return null;\n  }\n\n  const path: string = m[0];\n  const params: Params = { ...parentParams };\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,\n    keys: parentKeys.concat(regexp.keys),\n    params,\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { matchPath } from './match-path';\nimport { MatchedKeys, MatchedPath, MatchedRoute, Params, Route } from './types';\n\nexport function matchRoute<Context extends object, Result>(\n  route: Route<Context, Result>,\n  baseUrl: string,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n) {\n  let match: MatchedPath | null = null;\n  let childMatches: null | {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result>;\n  };\n  let childIndex = 0;\n\n  return {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result> {\n      if (route === routeToSkip) {\n        return { done: true, value: undefined };\n      }\n\n      if (!match) {\n        match = matchPath(route, pathname, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              baseUrl,\n              path: match.path,\n              keys: match.keys,\n              params: match.params,\n            },\n          };\n        }\n      }\n\n      if (match && route.children) {\n        while (childIndex < route.children.length) {\n          if (!childMatches) {\n            const childRoute = route.children[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + match.path,\n              pathname.substr(match.path.length),\n              match.keys,\n              match.params,\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true, value: undefined };\n    },\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { Params, ResultReturn, RouteContext } from './types';\n\nexport function resolveRoute<Context extends object, Result>(\n  context: RouteContext<Context, Result>,\n  params: Params,\n): ResultReturn<Result> {\n  if (typeof context.route.action === 'function') {\n    return context.route.action(context, params);\n  }\n\n  return undefined;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport { isChildRoute } from './is-child-route';\nimport { matchRoute } from './match-route';\nimport { resolveRoute } from './resolve-route';\nimport {\n  ErrorHandler,\n  MatchedRoute,\n  Options,\n  ResolveContext,\n  ResolveRoute,\n  ResultReturn,\n  Route,\n  RouteContext,\n  RouteOrRoutes,\n} from './types';\n\ntype RouterContext<Context extends object, Result> = Context & {\n  router: UniversalRouterSync<Context, Result>;\n};\n\nexport default class UniversalRouterSync<Context extends object, Result> {\n  static pathToRegexp = pathToRegexp;\n\n  baseUrl: string;\n  errorHandler?: ErrorHandler<Context, Result>;\n  resolveRoute: ResolveRoute<Context, Result>;\n  context: RouterContext<Context, Result>;\n  root: Route<Context, Result>;\n\n  constructor(\n    routes: RouteOrRoutes<Context, Result>,\n    options: Options<Context, Result> = { context: {} as Context },\n  ) {\n    if (!routes || typeof routes !== 'object') {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = { router: this, ...options.context } as RouterContext<Context, Result>;\n    this.root = Array.isArray(routes) ? { path: '', children: routes, parent: null } : routes;\n    this.root.parent = null;\n  }\n\n  resolve(pathnameOrContext: string | (ResolveContext & Context)): ResultReturn<Result> {\n    const context = {\n      ...this.context,\n      ...(typeof pathnameOrContext === 'string'\n        ? { pathname: pathnameOrContext }\n        : pathnameOrContext),\n    } as RouteContext<Context, Result>;\n    const match = matchRoute(\n      this.root,\n      this.baseUrl,\n      context.pathname.substr(this.baseUrl.length),\n      [],\n      null,\n    );\n    const resolve = this.resolveRoute;\n    let matches: MatchedRoute<Context, Result> | null = null;\n    let nextMatches: MatchedRoute<Context, Result> | null = null;\n    let currentContext = context;\n\n    function next(\n      resume?: boolean,\n      parent: Route<Context, Result> | null = matches && matches.value ? matches.value.route : null,\n      prevResult?: Result | null | undefined,\n    ): ResultReturn<Result> {\n      const lastRoute = matches && matches.value ? matches.value.route : null;\n      const routeToSkip = prevResult === null ? lastRoute : null;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n\n          return null;\n        }\n      }\n\n      if (matches.done) {\n        const error = new Error('Route not found');\n        (error as any).status = 404;\n        throw error;\n      }\n\n      currentContext = { ...context, ...matches.value };\n\n      const result = resolve(currentContext, matches.value.params);\n      if (result !== null && result !== undefined) {\n        return result;\n      }\n\n      return next(resume, parent, result);\n    }\n\n    context.next = next;\n\n    try {\n      return next(true, this.root);\n    } catch (error) {\n      if (this.errorHandler) {\n        return this.errorHandler(error, currentContext);\n      }\n      throw error;\n    }\n  }\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\ntype WithParent = {\n  parent?: WithParent | null | undefined;\n};\n\nexport function isChildRoute(\n  parentRoute: WithParent | null,\n  childRoute: WithParent | null | undefined,\n): boolean {\n  if (parentRoute === null) return false;\n\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","pathToRegexp","parse","str","options","tokensToFunction","tokensToRegExp","DEFAULT_DELIMITER","PATH_REGEXP","RegExp","join","res","group","tokens","key","index","path","defaultDelimiter","delimiter","whitelist","undefined","pathEscaped","exec","m","escaped","offset","slice","prev","name","capture","modifier","k","c","indexOf","push","repeat","optional","pattern","prefix","replace","escapeString","substr","matches","Array","data","encode","encodeURIComponent","token","segment","value","isArray","TypeError","j","test","String","flags","sensitive","keys","strict","start","end","endsWith","concat","map","route","endToken","isEndDelimited","groups","source","match","regexpToRegexp","parts","arrayToRegexp","stringToRegexp","cache","Map","decodeParam","val","decodeURIComponent","err","matchRoute","baseUrl","pathname","parentKeys","parentParams","childMatches","childIndex","next","routeToSkip","done","children","cacheKey","regexp","get","set","params","prop","split","charAt","matchPath","childRoute","parent","childMatch","resolveRoute","context","action","routes","errorHandler","tslib_1.__assign","router","root","UniversalRouterSync","pathnameOrContext","resolve","nextMatches","currentContext","resume","prevResult","lastRoute","parentRoute","isChildRoute","error","Error","status","result"],"mappings":"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"}