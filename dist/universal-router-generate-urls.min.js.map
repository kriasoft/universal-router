{"version":3,"file":"universal-router-generate-urls.min.js","sources":["../src/is-child-route.ts","../src/match-path.ts","../src/match-route.ts","../src/resolve-route.ts","../src/universal-router.ts","../src/generate-urls.ts"],"sourcesContent":["/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\ntype WithParent = {\n  parent?: WithParent | null | undefined;\n};\n\nexport function isChildRoute(\n  parentRoute: WithParent | null,\n  childRoute: WithParent | null | undefined,\n): boolean {\n  if (parentRoute === null) return false;\n\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp'; // keep require\nimport { MatchedKeys, MatchedPath, Params, Route } from './types';\n\ntype RegexpCache = {\n  keys: MatchedKeys;\n  pattern: RegExp;\n};\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst cache = new Map<string, RegexpCache>();\n\nfunction decodeParam(val: string): string {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nexport function matchPath<Context extends object, Result>(\n  route: Route<Context, Result>,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n): MatchedPath | null {\n  const end = !route.children;\n  const cacheKey = `${route.path || ''}|${end}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys: MatchedKeys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(route.path || '', keys, { end }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(pathname);\n  if (!m) {\n    return null;\n  }\n\n  const path: string = m[0];\n  const params: Params = { ...parentParams };\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,\n    keys: parentKeys.concat(regexp.keys),\n    params,\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { matchPath } from './match-path';\nimport { MatchedKeys, MatchedPath, MatchedRoute, Params, Route } from './types';\n\nexport function matchRoute<Context extends object, Result>(\n  route: Route<Context, Result>,\n  baseUrl: string,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n) {\n  let match: MatchedPath | null = null;\n  let childMatches: null | {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result>;\n  };\n  let childIndex = 0;\n\n  return {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result> {\n      if (route === routeToSkip) {\n        return { done: true, value: undefined };\n      }\n\n      if (!match) {\n        match = matchPath(route, pathname, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              baseUrl,\n              path: match.path,\n              keys: match.keys,\n              params: match.params,\n            },\n          };\n        }\n      }\n\n      if (match && route.children) {\n        while (childIndex < route.children.length) {\n          if (!childMatches) {\n            const childRoute = route.children[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + match.path,\n              pathname.substr(match.path.length),\n              match.keys,\n              match.params,\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true, value: undefined };\n    },\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { Params, ResultReturn, RouteContext } from './types';\n\nexport function resolveRoute<Context extends object, Result>(\n  context: RouteContext<Context, Result>,\n  params: Params,\n): ResultReturn<Result> {\n  if (typeof context.route.action === 'function') {\n    return context.route.action(context, params);\n  }\n\n  return undefined;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport { isChildRoute } from './is-child-route';\nimport { matchRoute } from './match-route';\nimport { resolveRoute } from './resolve-route';\nimport {\n  ErrorHandler,\n  MatchedRoute,\n  Options,\n  ResolveContext,\n  ResolveRoute,\n  ResultReturn,\n  Route,\n  RouteContext,\n  RouteNameMap,\n  RouteOrRoutes,\n} from './types';\n\ntype RouterContext<Context extends object, Result> = Context & {\n  router: UniversalRouter<Context, Result>;\n};\n\nexport default class UniversalRouter<Context extends object, Result> {\n  static pathToRegexp = pathToRegexp;\n\n  routesByName?: RouteNameMap;\n\n  baseUrl: string;\n  errorHandler?: ErrorHandler<Context, Result>;\n  resolveRoute: ResolveRoute<Context, Result>;\n  context: RouterContext<Context, Result>;\n  root: Route<Context, Result>;\n\n  constructor(\n    routes: RouteOrRoutes<Context, Result>,\n    options: Options<Context, Result> = { context: {} as Context },\n  ) {\n    if (!routes || typeof routes !== 'object') {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = { router: this, ...options.context } as RouterContext<Context, Result>;\n    this.root = Array.isArray(routes) ? { path: '', children: routes, parent: null } : routes;\n    this.root.parent = null;\n  }\n\n  resolve(pathnameOrContext: string | (ResolveContext & Context)): ResultReturn<Result> {\n    const context = {\n      ...this.context,\n      ...(typeof pathnameOrContext === 'string'\n        ? { pathname: pathnameOrContext }\n        : pathnameOrContext),\n    } as RouteContext<Context, Result>;\n    const match = matchRoute(\n      this.root,\n      this.baseUrl,\n      context.pathname.substr(this.baseUrl.length),\n      [],\n      null,\n    );\n    const resolve = this.resolveRoute;\n    let matches: MatchedRoute<Context, Result> | null = null;\n    let nextMatches: MatchedRoute<Context, Result> | null = null;\n    let currentContext = context;\n\n    function next(\n      resume?: boolean,\n      parent: Route<Context, Result> | null = matches && matches.value ? matches.value.route : null,\n      prevResult?: Result | null | undefined,\n    ): ResultReturn<Result> {\n      const lastRoute = matches && matches.value ? matches.value.route : null;\n      const routeToSkip = prevResult === null ? lastRoute : null;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n\n          return Promise.resolve(null);\n        }\n      }\n\n      if (matches.done) {\n        const error = new Error('Route not found');\n        (error as any).status = 404;\n\n        return Promise.reject(error);\n      }\n\n      const resolveContext = { ...context, ...matches.value };\n      currentContext = resolveContext;\n\n      return Promise.resolve(resolve(resolveContext, matches.value.params)).then((result) => {\n        if (result !== null && result !== undefined) {\n          return result;\n        }\n\n        return next(resume, parent, result);\n      });\n    }\n\n    context.next = next;\n\n    return Promise.resolve()\n      .then(() => next(true, this.root))\n      .catch((error) => {\n        if (this.errorHandler) {\n          return this.errorHandler(error, currentContext);\n        }\n        throw error;\n      });\n  }\n}\n","import { Params, Route, RouteNameMap, Routes } from './types';\nimport UniversalRouter from './universal-router';\n\nconst { pathToRegexp } = UniversalRouter;\nconst cache = new Map();\n\nfunction cacheRoutes(\n  routesByName: RouteNameMap,\n  route: Route<any, any>,\n  routes?: Routes<any, any> | null | undefined,\n): void {\n  if (routesByName.has(route.name as string)) {\n    throw new Error(`Route \"${route.name}\" already exists`);\n  }\n\n  if (route.name) {\n    routesByName.set(route.name, route);\n  }\n\n  if (routes) {\n    for (let i = 0; i < routes.length; i++) {\n      const childRoute = routes[i];\n      childRoute.parent = route;\n      cacheRoutes(routesByName, childRoute, childRoute.children);\n    }\n  }\n}\n\nexport default function generateUrls(router: UniversalRouter<any, any>, options: any = {}) {\n  if (!(router instanceof UniversalRouter)) {\n    const duck: any = router;\n    if (typeof duck !== 'object' || !duck || !duck.root) {\n      throw new TypeError('An instance of UniversalRouter is expected');\n    }\n  }\n\n  router.routesByName = router.routesByName || new Map();\n\n  return (routeName: string, params: Params) => {\n    const map = router.routesByName as RouteNameMap;\n    let route = map.get(routeName);\n    if (!route) {\n      map.clear(); // clear cache\n      cacheRoutes(map, router.root, router.root.children);\n\n      route = map.get(routeName);\n      if (!route) {\n        throw new Error(`Route \"${routeName}\" not found`);\n      }\n    }\n\n    let regexp = cache.get(route.fullPath);\n    if (!regexp) {\n      let fullPath = '';\n      let rt = route;\n      while (rt) {\n        const path = Array.isArray(rt.path) ? rt.path[0] : rt.path;\n        if (path) {\n          fullPath = path + fullPath;\n        }\n        rt = rt.parent;\n      }\n      const tokens = pathToRegexp.parse(fullPath);\n      const toPath = pathToRegexp.tokensToFunction(tokens);\n      const keys: any = Object.create(null);\n      for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (typeof token !== 'string') {\n          keys[token.name] = true;\n        }\n      }\n      regexp = { toPath, keys };\n      cache.set(fullPath, regexp);\n      route.fullPath = fullPath;\n    }\n\n    let url = router.baseUrl + regexp.toPath(params, options) || '/';\n\n    if (options.stringifyQueryParams && params) {\n      const queryParams: any = {};\n      const keys = Object.keys(params);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (!regexp.keys[key]) {\n          queryParams[key] = params[key];\n        }\n      }\n      const query = options.stringifyQueryParams(queryParams);\n      if (query) {\n        url += query.charAt(0) === '?' ? query : `?${query}`;\n      }\n    }\n\n    return url;\n  };\n}\n"],"names":["isChildRoute","parentRoute","childRoute","route","parent","hasOwnProperty","Object","prototype","cache","Map","decodeParam","val","decodeURIComponent","err","matchPath","pathname","parentKeys","parentParams","end","children","cacheKey","path","regexp","get","keys","pattern","pathToRegexp","set","m","exec","params","i","length","key","prop","name","value","undefined","call","repeat","split","delimiter","map","charAt","substr","concat","matchRoute","baseUrl","childMatches","match","childIndex","[object Object]","routeToSkip","done","childMatch","next","resolveRoute","context","action","UniversalRouter","routes","options","TypeError","this","errorHandler","router","root","Array","isArray","pathnameOrContext","resolve","matches","nextMatches","currentContext","resume","prevResult","lastRoute","Promise","error","Error","status","reject","resolveContext","then","result","catch","cacheRoutes","routesByName","has","generateUrls","duck","routeName","clear","fullPath","rt","tokens","parse","toPath","tokensToFunction","create","token","url","stringifyQueryParams","queryParams","query"],"mappings":"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"}