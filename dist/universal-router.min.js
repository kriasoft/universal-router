"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var pathToRegexp=_interopDefault(require("path-to-regexp"));function isChildRoute(e,t){if(null===e)return!1;let r=t;for(;r;)if((r=r.parent)===e)return!0;return!1}const{hasOwnProperty:hasOwnProperty}=Object.prototype,cache=new Map;function decodeParam(e){try{return decodeURIComponent(e)}catch(t){return e}}function matchPath(e,t,r,n){const o=!e.children,a=`${e.path||""}|${o}`;let l=cache.get(a);if(!l){const t=[];l={keys:t,pattern:pathToRegexp(e.path||"",t,{end:o})},cache.set(a,l)}const u=l.pattern.exec(t);if(!u)return null;const s=u[0],i={...n};for(let e=1;e<u.length;e++){const t=l.keys[e-1],r=t.name,n=u[e];void 0===n&&hasOwnProperty.call(i,r)||(t.repeat?i[r]=n?n.split(t.delimiter).map(decodeParam):[]:i[r]=n?decodeParam(n):n)}return{path:o||"/"!==s.charAt(s.length-1)?s:s.substr(1),keys:r.concat(l.keys),params:i}}function matchRoute(e,t,r,n,o){let a,l=null,u=0;return{next(s){if(e===s)return{done:!0,value:void 0};if(!l&&(l=matchPath(e,r,n,o)))return{done:!1,value:{route:e,baseUrl:t,path:l.path,keys:l.keys,params:l.params}};if(l&&e.children)for(;u<e.children.length;){if(!a){const n=e.children[u];n.parent=e,a=matchRoute(n,t+l.path,r.substr(l.path.length),l.keys,l.params)}const n=a.next(s);if(!n.done)return{done:!1,value:n.value};a=null,u++}return{done:!0,value:void 0}}}}function resolveRoute(e,t){if("function"==typeof e.route.action)return e.route.action(e,t)}class UniversalRouter{constructor(e,t={context:{}}){if(!e||"object"!=typeof e)throw new TypeError("Invalid routes");this.baseUrl=t.baseUrl||"",this.errorHandler=t.errorHandler,this.resolveRoute=t.resolveRoute||resolveRoute,this.context={router:this,...t.context},this.root=Array.isArray(e)?{path:"",children:e,parent:null}:e,this.root.parent=null}resolve(e){const t={...this.context,..."string"==typeof e?{pathname:e}:e},r=matchRoute(this.root,this.baseUrl,t.pathname.substr(this.baseUrl.length),[],null),n=this.resolveRoute;let o=null,a=null,l=t;function u(e,s=(o&&o.value?o.value.route:null),i){const c=o&&o.value?o.value.route:null,h=null===i?c:null;if(o=a||r.next(h),a=null,!e&&(o.done||!isChildRoute(s,o.value.route)))return a=o,Promise.resolve(null);if(o.done){const e=new Error("Route not found");return e.status=404,Promise.reject(e)}const p={...t,...o.value};return l=p,Promise.resolve(n(p,o.value.params)).then(t=>null!=t?t:u(e,s,t))}return t.next=u,Promise.resolve().then(()=>u(!0,this.root)).catch(e=>{if(this.errorHandler)return this.errorHandler(e,l);throw e})}}UniversalRouter.pathToRegexp=pathToRegexp,module.exports=UniversalRouter;
//# sourceMappingURL=universal-router.min.js.map
