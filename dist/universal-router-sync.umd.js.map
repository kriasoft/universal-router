{"version":3,"file":"universal-router-sync.umd.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/path-to-regexp/index.js","../src/is-child-route.ts","../src/match-path.ts","../src/match-route.ts","../src/resolve-route.ts","../src/universal-router-sync.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\ntype WithParent = {\n  parent?: WithParent | null | undefined;\n};\n\nexport function isChildRoute(\n  parentRoute: WithParent | null,\n  childRoute: WithParent | null | undefined,\n): boolean {\n  if (parentRoute === null) return false;\n\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp'; // keep require\nimport { MatchedKeys, MatchedPath, Params, Route } from './types';\n\ntype RegexpCache = {\n  keys: MatchedKeys;\n  pattern: RegExp;\n};\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst cache = new Map<string, RegexpCache>();\n\nfunction decodeParam(val: string): string {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nexport function matchPath<Context extends object, Result>(\n  route: Route<Context, Result>,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n): MatchedPath | null {\n  const end = !route.children;\n  const cacheKey = `${route.path || ''}|${end}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys: MatchedKeys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(route.path || '', keys, { end }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(pathname);\n  if (!m) {\n    return null;\n  }\n\n  const path: string = m[0];\n  const params: Params = { ...parentParams };\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,\n    keys: parentKeys.concat(regexp.keys),\n    params,\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { matchPath } from './match-path';\nimport { MatchedKeys, MatchedPath, MatchedRoute, Params, Route } from './types';\n\nexport function matchRoute<Context extends object, Result>(\n  route: Route<Context, Result>,\n  baseUrl: string,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n) {\n  let match: MatchedPath | null = null;\n  let childMatches: null | {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result>;\n  };\n  let childIndex = 0;\n\n  return {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result> {\n      if (route === routeToSkip) {\n        return { done: true, value: undefined };\n      }\n\n      if (!match) {\n        match = matchPath(route, pathname, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              baseUrl,\n              path: match.path,\n              keys: match.keys,\n              params: match.params,\n            },\n          };\n        }\n      }\n\n      if (match && route.children) {\n        while (childIndex < route.children.length) {\n          if (!childMatches) {\n            const childRoute = route.children[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + match.path,\n              pathname.substr(match.path.length),\n              match.keys,\n              match.params,\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true, value: undefined };\n    },\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { Params, ResultReturn, RouteContext } from './types';\n\nexport function resolveRoute<Context extends object, Result>(\n  context: RouteContext<Context, Result>,\n  params: Params,\n): ResultReturn<Result> {\n  if (typeof context.route.action === 'function') {\n    return context.route.action(context, params);\n  }\n\n  return undefined;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport { isChildRoute } from './is-child-route';\nimport { matchRoute } from './match-route';\nimport { resolveRoute } from './resolve-route';\nimport {\n  ErrorHandler,\n  MatchedRoute,\n  Options,\n  ResolveContext,\n  ResolveRoute,\n  ResultReturn,\n  Route,\n  RouteContext,\n  RouteOrRoutes,\n} from './types';\n\ntype RouterContext<Context extends object, Result> = Context & {\n  router: UniversalRouterSync<Context, Result>;\n};\n\nexport default class UniversalRouterSync<Context extends object, Result> {\n  static pathToRegexp = pathToRegexp;\n\n  baseUrl: string;\n  errorHandler?: ErrorHandler<Context, Result>;\n  resolveRoute: ResolveRoute<Context, Result>;\n  context: RouterContext<Context, Result>;\n  root: Route<Context, Result>;\n\n  constructor(\n    routes: RouteOrRoutes<Context, Result>,\n    options: Options<Context, Result> = { context: {} as Context },\n  ) {\n    if (!routes || typeof routes !== 'object') {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = { router: this, ...options.context } as RouterContext<Context, Result>;\n    this.root = Array.isArray(routes) ? { path: '', children: routes, parent: null } : routes;\n    this.root.parent = null;\n  }\n\n  resolve(pathnameOrContext: string | (ResolveContext & Context)): ResultReturn<Result> {\n    const context = {\n      ...this.context,\n      ...(typeof pathnameOrContext === 'string'\n        ? { pathname: pathnameOrContext }\n        : pathnameOrContext),\n    } as RouteContext<Context, Result>;\n    const match = matchRoute(\n      this.root,\n      this.baseUrl,\n      context.pathname.substr(this.baseUrl.length),\n      [],\n      null,\n    );\n    const resolve = this.resolveRoute;\n    let matches: MatchedRoute<Context, Result> | null = null;\n    let nextMatches: MatchedRoute<Context, Result> | null = null;\n    let currentContext = context;\n\n    function next(\n      resume?: boolean,\n      parent: Route<Context, Result> | null = matches && matches.value ? matches.value.route : null,\n      prevResult?: Result | null | undefined,\n    ): ResultReturn<Result> {\n      const lastRoute = matches && matches.value ? matches.value.route : null;\n      const routeToSkip = prevResult === null ? lastRoute : null;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n\n          return null;\n        }\n      }\n\n      if (matches.done) {\n        const error = new Error('Route not found');\n        (error as any).status = 404;\n        throw error;\n      }\n\n      currentContext = { ...context, ...matches.value };\n\n      const result = resolve(currentContext, matches.value.params);\n      if (result !== null && result !== undefined) {\n        return result;\n      }\n\n      return next(resume, parent, result);\n    }\n\n    context.next = next;\n\n    try {\n      return next(true, this.root);\n    } catch (error) {\n      if (this.errorHandler) {\n        return this.errorHandler(error, currentContext);\n      }\n      throw error;\n    }\n  }\n}\n"],"names":["pathToRegexp","tslib_1.__assign"],"mappings":"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"}