import e from"path-to-regexp";const{hasOwnProperty:t}=Object.prototype,r=new Map;function n(e){try{return decodeURIComponent(e)}catch(t){return e}}function o(s,a,l,u,i){let c,h=null,p=0;return{next(f){if(s===f)return{done:!0,value:void 0};if(!h&&(h=function(o,s,a,l){const u=!o.children,i=`${o.path||""}|${u}`;let c=r.get(i);if(!c){const t=[];c={keys:t,pattern:e(o.path||"",t,{end:u})},r.set(i,c)}const h=c.pattern.exec(s);if(!h)return null;const p=h[0],f={...l};for(let e=1;e<h.length;e++){const r=c.keys[e-1],o=r.name,s=h[e];void 0===s&&t.call(f,o)||(r.repeat?f[o]=s?s.split(r.delimiter).map(n):[]:f[o]=s?n(s):s)}return{path:u||"/"!==p.charAt(p.length-1)?p:p.substr(1),keys:a.concat(c.keys),params:f}}(s,l,u,i)))return{done:!1,value:{route:s,baseUrl:a,path:h.path,keys:h.keys,params:h.params}};if(h&&s.children)for(;p<s.children.length;){if(!c){const e=s.children[p];e.parent=s,c=o(e,a+h.path,l.substr(h.path.length),h.keys,h.params)}const e=c.next(f);if(!e.done)return{done:!1,value:e.value};c=null,p++}return{done:!0,value:void 0}}}}function s(e,t){if("function"==typeof e.route.action)return e.route.action(e,t)}class a{constructor(e,t={context:{}}){if(!e||"object"!=typeof e)throw new TypeError("Invalid routes");this.baseUrl=t.baseUrl||"",this.errorHandler=t.errorHandler,this.resolveRoute=t.resolveRoute||s,this.context={router:this,...t.context},this.root=Array.isArray(e)?{path:"",children:e,parent:null}:e,this.root.parent=null}resolve(e){const t={...this.context,..."string"==typeof e?{pathname:e}:e},r=o(this.root,this.baseUrl,t.pathname.substr(this.baseUrl.length),[],null),n=this.resolveRoute;let s=null,a=null,l=t;function u(e,o=(s&&s.value?s.value.route:null),i){const c=s&&s.value?s.value.route:null,h=null===i?c:null;if(s=a||r.next(h),a=null,!e&&(s.done||!function(e,t){if(null===e)return!1;let r=t;for(;r;)if((r=r.parent)===e)return!0;return!1}(o,s.value.route)))return a=s,Promise.resolve(null);if(s.done){const e=new Error("Route not found");return e.status=404,Promise.reject(e)}const p={...t,...s.value};return l=p,Promise.resolve(n(p,s.value.params)).then(t=>null!=t?t:u(e,o,t))}return t.next=u,Promise.resolve().then(()=>u(!0,this.root)).catch(e=>{if(this.errorHandler)return this.errorHandler(e,l);throw e})}}a.pathToRegexp=e;const{pathToRegexp:l}=a,u=new Map;function i(e,t={}){if(!(e instanceof a)){const t=e;if("object"!=typeof t||!t||!t.root)throw new TypeError("An instance of UniversalRouter is expected")}return e.routesByName=e.routesByName||new Map,(r,n)=>{const o=e.routesByName;let s=o.get(r);if(!(s||(o.clear(),function e(t,r,n){if(t.has(r.name))throw new Error(`Route "${r.name}" already exists`);if(r.name&&t.set(r.name,r),n)for(let o=0;o<n.length;o++){const s=n[o];s.parent=r,e(t,s,s.children)}}(o,e.root,e.root.children),s=o.get(r))))throw new Error(`Route "${r}" not found`);let a=u.get(s.fullPath);if(!a){let e="",t=s;for(;t;){const r=Array.isArray(t.path)?t.path[0]:t.path;r&&(e=r+e),t=t.parent}const r=l.parse(e),n=l.tokensToFunction(r),o=Object.create(null);for(let e=0;e<r.length;e++){const t=r[e];"string"!=typeof t&&(o[t.name]=!0)}a={toPath:n,keys:o},u.set(e,a),s.fullPath=e}let i=e.baseUrl+a.toPath(n,t)||"/";if(t.stringifyQueryParams&&n){const e={},r=Object.keys(n);for(let t=0;t<r.length;t++){const o=r[t];a.keys[o]||(e[o]=n[o])}const o=t.stringifyQueryParams(e);o&&(i+="?"===o.charAt(0)?o:`?${o}`)}return i}}export{a as UniversalRouter,i as generateUrls};
//# sourceMappingURL=universal-router-generate-urls.esm.min.js.map
