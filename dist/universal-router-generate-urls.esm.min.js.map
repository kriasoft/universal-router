{"version":3,"file":"universal-router-generate-urls.esm.min.js","sources":["../src/match-path.ts","../src/match-route.ts","../src/resolve-route.ts","../src/universal-router.ts","../src/is-child-route.ts","../src/generate-urls.ts"],"sourcesContent":["/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp'; // keep require\nimport { MatchedKeys, MatchedPath, Params, Route } from './types';\n\ntype RegexpCache = {\n  keys: MatchedKeys;\n  pattern: RegExp;\n};\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst cache = new Map<string, RegexpCache>();\n\nfunction decodeParam(val: string): string {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nexport function matchPath<Context extends object, Result>(\n  route: Route<Context, Result>,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n): MatchedPath | null {\n  const end = !route.children;\n  const cacheKey = `${route.path || ''}|${end}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys: MatchedKeys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(route.path || '', keys, { end }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(pathname);\n  if (!m) {\n    return null;\n  }\n\n  const path: string = m[0];\n  const params: Params = { ...parentParams };\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,\n    keys: parentKeys.concat(regexp.keys),\n    params,\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { matchPath } from './match-path';\nimport { MatchedKeys, MatchedPath, MatchedRoute, Params, Route } from './types';\n\nexport function matchRoute<Context extends object, Result>(\n  route: Route<Context, Result>,\n  baseUrl: string,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n) {\n  let match: MatchedPath | null = null;\n  let childMatches: null | {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result>;\n  };\n  let childIndex = 0;\n\n  return {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result> {\n      if (route === routeToSkip) {\n        return { done: true, value: undefined };\n      }\n\n      if (!match) {\n        match = matchPath(route, pathname, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              baseUrl,\n              path: match.path,\n              keys: match.keys,\n              params: match.params,\n            },\n          };\n        }\n      }\n\n      if (match && route.children) {\n        while (childIndex < route.children.length) {\n          if (!childMatches) {\n            const childRoute = route.children[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + match.path,\n              pathname.substr(match.path.length),\n              match.keys,\n              match.params,\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true, value: undefined };\n    },\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { Params, ResultReturn, RouteContext } from './types';\n\nexport function resolveRoute<Context extends object, Result>(\n  context: RouteContext<Context, Result>,\n  params: Params,\n): ResultReturn<Result> {\n  if (typeof context.route.action === 'function') {\n    return context.route.action(context, params);\n  }\n\n  return undefined;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport { isChildRoute } from './is-child-route';\nimport { matchRoute } from './match-route';\nimport { resolveRoute } from './resolve-route';\nimport {\n  ErrorHandler,\n  MatchedRoute,\n  Options,\n  ResolveContext,\n  ResolveRoute,\n  ResultReturn,\n  Route,\n  RouteContext,\n  RouteNameMap,\n  RouteOrRoutes,\n} from './types';\n\ntype RouterContext<Context extends object, Result> = Context & {\n  router: UniversalRouter<Context, Result>;\n};\n\nexport default class UniversalRouter<Context extends object, Result> {\n  static pathToRegexp = pathToRegexp;\n\n  routesByName?: RouteNameMap;\n\n  baseUrl: string;\n  errorHandler?: ErrorHandler<Context, Result>;\n  resolveRoute: ResolveRoute<Context, Result>;\n  context: RouterContext<Context, Result>;\n  root: Route<Context, Result>;\n\n  constructor(\n    routes: RouteOrRoutes<Context, Result>,\n    options: Options<Context, Result> = { context: {} as Context },\n  ) {\n    if (!routes || typeof routes !== 'object') {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = { router: this, ...options.context } as RouterContext<Context, Result>;\n    this.root = Array.isArray(routes) ? { path: '', children: routes, parent: null } : routes;\n    this.root.parent = null;\n  }\n\n  resolve(pathnameOrContext: string | (ResolveContext & Context)): ResultReturn<Result> {\n    const context = {\n      ...this.context,\n      ...(typeof pathnameOrContext === 'string'\n        ? { pathname: pathnameOrContext }\n        : pathnameOrContext),\n    } as RouteContext<Context, Result>;\n    const match = matchRoute(\n      this.root,\n      this.baseUrl,\n      context.pathname.substr(this.baseUrl.length),\n      [],\n      null,\n    );\n    const resolve = this.resolveRoute;\n    let matches: MatchedRoute<Context, Result> | null = null;\n    let nextMatches: MatchedRoute<Context, Result> | null = null;\n    let currentContext = context;\n\n    function next(\n      resume?: boolean,\n      parent: Route<Context, Result> | null = matches && matches.value ? matches.value.route : null,\n      prevResult?: Result | null | undefined,\n    ): ResultReturn<Result> {\n      const lastRoute = matches && matches.value ? matches.value.route : null;\n      const routeToSkip = prevResult === null ? lastRoute : null;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n\n          return Promise.resolve(null);\n        }\n      }\n\n      if (matches.done) {\n        const error = new Error('Route not found');\n        (error as any).status = 404;\n\n        return Promise.reject(error);\n      }\n\n      const resolveContext = { ...context, ...matches.value };\n      currentContext = resolveContext;\n\n      return Promise.resolve(resolve(resolveContext, matches.value.params)).then((result) => {\n        if (result !== null && result !== undefined) {\n          return result;\n        }\n\n        return next(resume, parent, result);\n      });\n    }\n\n    context.next = next;\n\n    return Promise.resolve()\n      .then(() => next(true, this.root))\n      .catch((error) => {\n        if (this.errorHandler) {\n          return this.errorHandler(error, currentContext);\n        }\n        throw error;\n      });\n  }\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\ntype WithParent = {\n  parent?: WithParent | null | undefined;\n};\n\nexport function isChildRoute(\n  parentRoute: WithParent | null,\n  childRoute: WithParent | null | undefined,\n): boolean {\n  if (parentRoute === null) return false;\n\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { Params, Route, RouteNameMap, Routes } from './types';\nimport UniversalRouter from './universal-router';\n\nconst { pathToRegexp } = UniversalRouter;\nconst cache = new Map();\n\nfunction cacheRoutes(\n  routesByName: RouteNameMap,\n  route: Route<any, any>,\n  routes?: Routes<any, any> | null | undefined,\n): void {\n  if (routesByName.has(route.name as string)) {\n    throw new Error(`Route \"${route.name}\" already exists`);\n  }\n\n  if (route.name) {\n    routesByName.set(route.name, route);\n  }\n\n  if (routes) {\n    for (let i = 0; i < routes.length; i++) {\n      const childRoute = routes[i];\n      childRoute.parent = route;\n      cacheRoutes(routesByName, childRoute, childRoute.children);\n    }\n  }\n}\n\nexport default function generateUrls(router: UniversalRouter<any, any>, options: any = {}) {\n  if (!(router instanceof UniversalRouter)) {\n    const duck: any = router;\n    if (typeof duck !== 'object' || !duck || !duck.root) {\n      throw new TypeError('An instance of UniversalRouter is expected');\n    }\n  }\n\n  router.routesByName = router.routesByName || new Map();\n\n  return (routeName: string, params: Params) => {\n    const map = router.routesByName as RouteNameMap;\n    let route = map.get(routeName);\n    if (!route) {\n      map.clear(); // clear cache\n      cacheRoutes(map, router.root, router.root.children);\n\n      route = map.get(routeName);\n      if (!route) {\n        throw new Error(`Route \"${routeName}\" not found`);\n      }\n    }\n\n    let regexp = cache.get(route.fullPath);\n    if (!regexp) {\n      let fullPath = '';\n      let rt = route;\n      while (rt) {\n        const path = Array.isArray(rt.path) ? rt.path[0] : rt.path;\n        if (path) {\n          fullPath = path + fullPath;\n        }\n        rt = rt.parent;\n      }\n      const tokens = pathToRegexp.parse(fullPath);\n      const toPath = pathToRegexp.tokensToFunction(tokens);\n      const keys: any = Object.create(null);\n      for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (typeof token !== 'string') {\n          keys[token.name] = true;\n        }\n      }\n      regexp = { toPath, keys };\n      cache.set(fullPath, regexp);\n      route.fullPath = fullPath;\n    }\n\n    let url = router.baseUrl + regexp.toPath(params, options) || '/';\n\n    if (options.stringifyQueryParams && params) {\n      const queryParams: any = {};\n      const keys = Object.keys(params);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (!regexp.keys[key]) {\n          queryParams[key] = params[key];\n        }\n      }\n      const query = options.stringifyQueryParams(queryParams);\n      if (query) {\n        url += query.charAt(0) === '?' ? query : `?${query}`;\n      }\n    }\n\n    return url;\n  };\n}\n"],"names":["hasOwnProperty","Object","prototype","cache","Map","decodeParam","val","decodeURIComponent","err","matchRoute","route","baseUrl","pathname","parentKeys","parentParams","childMatches","match","childIndex","[object Object]","routeToSkip","done","value","undefined","end","children","cacheKey","path","regexp","get","keys","pattern","pathToRegexp","set","m","exec","params","i","length","key","prop","name","call","repeat","split","delimiter","map","charAt","substr","concat","matchPath","childRoute","parent","childMatch","next","resolveRoute","context","action","UniversalRouter","routes","options","TypeError","this","errorHandler","router","root","Array","isArray","pathnameOrContext","resolve","matches","nextMatches","currentContext","resume","prevResult","lastRoute","parentRoute","isChildRoute","Promise","error","Error","status","reject","resolveContext","then","result","catch","generateUrls","duck","routesByName","routeName","clear","cacheRoutes","has","fullPath","rt","tokens","parse","toPath","tokensToFunction","create","token","url","stringifyQueryParams","queryParams","query"],"mappings":"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"}