{"version":3,"file":"universal-router-sync.min.js","sources":["../src/is-child-route.ts","../src/match-path.ts","../src/match-route.ts","../src/resolve-route.ts","../src/universal-router-sync.ts"],"sourcesContent":["/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\ntype WithParent = {\n  parent?: WithParent | null | undefined;\n};\n\nexport function isChildRoute(\n  parentRoute: WithParent | null,\n  childRoute: WithParent | null | undefined,\n): boolean {\n  if (parentRoute === null) return false;\n\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp'; // keep require\nimport { MatchedKeys, MatchedPath, Params, Route } from './types';\n\ntype RegexpCache = {\n  keys: MatchedKeys;\n  pattern: RegExp;\n};\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst cache = new Map<string, RegexpCache>();\n\nfunction decodeParam(val: string): string {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nexport function matchPath<Context extends object, Result>(\n  route: Route<Context, Result>,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n): MatchedPath | null {\n  const end = !route.children;\n  const cacheKey = `${route.path || ''}|${end}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys: MatchedKeys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(route.path || '', keys, { end }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(pathname);\n  if (!m) {\n    return null;\n  }\n\n  const path: string = m[0];\n  const params: Params = { ...parentParams };\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,\n    keys: parentKeys.concat(regexp.keys),\n    params,\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { matchPath } from './match-path';\nimport { MatchedKeys, MatchedPath, MatchedRoute, Params, Route } from './types';\n\nexport function matchRoute<Context extends object, Result>(\n  route: Route<Context, Result>,\n  baseUrl: string,\n  pathname: string,\n  parentKeys: MatchedKeys,\n  parentParams?: Params | null,\n) {\n  let match: MatchedPath | null = null;\n  let childMatches: null | {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result>;\n  };\n  let childIndex = 0;\n\n  return {\n    next(routeToSkip?: Route<Context, Result> | null): MatchedRoute<Context, Result> {\n      if (route === routeToSkip) {\n        return { done: true, value: undefined };\n      }\n\n      if (!match) {\n        match = matchPath(route, pathname, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              baseUrl,\n              path: match.path,\n              keys: match.keys,\n              params: match.params,\n            },\n          };\n        }\n      }\n\n      if (match && route.children) {\n        while (childIndex < route.children.length) {\n          if (!childMatches) {\n            const childRoute = route.children[childIndex];\n            childRoute.parent = route;\n\n            childMatches = matchRoute(\n              childRoute,\n              baseUrl + match.path,\n              pathname.substr(match.path.length),\n              match.keys,\n              match.params,\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return { done: true, value: undefined };\n    },\n  };\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport { Params, ResultReturn, RouteContext } from './types';\n\nexport function resolveRoute<Context extends object, Result>(\n  context: RouteContext<Context, Result>,\n  params: Params,\n): ResultReturn<Result> {\n  if (typeof context.route.action === 'function') {\n    return context.route.action(context, params);\n  }\n\n  return undefined;\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport { isChildRoute } from './is-child-route';\nimport { matchRoute } from './match-route';\nimport { resolveRoute } from './resolve-route';\nimport {\n  ErrorHandler,\n  MatchedRoute,\n  Options,\n  ResolveContext,\n  ResolveRoute,\n  ResultReturn,\n  Route,\n  RouteContext,\n  RouteOrRoutes,\n} from './types';\n\ntype RouterContext<Context extends object, Result> = Context & {\n  router: UniversalRouterSync<Context, Result>;\n};\n\nexport default class UniversalRouterSync<Context extends object, Result> {\n  static pathToRegexp = pathToRegexp;\n\n  baseUrl: string;\n  errorHandler?: ErrorHandler<Context, Result>;\n  resolveRoute: ResolveRoute<Context, Result>;\n  context: RouterContext<Context, Result>;\n  root: Route<Context, Result>;\n\n  constructor(\n    routes: RouteOrRoutes<Context, Result>,\n    options: Options<Context, Result> = { context: {} as Context },\n  ) {\n    if (!routes || typeof routes !== 'object') {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = { router: this, ...options.context } as RouterContext<Context, Result>;\n    this.root = Array.isArray(routes) ? { path: '', children: routes, parent: null } : routes;\n    this.root.parent = null;\n  }\n\n  resolve(pathnameOrContext: string | (ResolveContext & Context)): ResultReturn<Result> {\n    const context = {\n      ...this.context,\n      ...(typeof pathnameOrContext === 'string'\n        ? { pathname: pathnameOrContext }\n        : pathnameOrContext),\n    } as RouteContext<Context, Result>;\n    const match = matchRoute(\n      this.root,\n      this.baseUrl,\n      context.pathname.substr(this.baseUrl.length),\n      [],\n      null,\n    );\n    const resolve = this.resolveRoute;\n    let matches: MatchedRoute<Context, Result> | null = null;\n    let nextMatches: MatchedRoute<Context, Result> | null = null;\n    let currentContext = context;\n\n    function next(\n      resume?: boolean,\n      parent: Route<Context, Result> | null = matches && matches.value ? matches.value.route : null,\n      prevResult?: Result | null | undefined,\n    ): ResultReturn<Result> {\n      const lastRoute = matches && matches.value ? matches.value.route : null;\n      const routeToSkip = prevResult === null ? lastRoute : null;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n\n          return null;\n        }\n      }\n\n      if (matches.done) {\n        const error = new Error('Route not found');\n        (error as any).status = 404;\n        throw error;\n      }\n\n      currentContext = { ...context, ...matches.value };\n\n      const result = resolve(currentContext, matches.value.params);\n      if (result !== null && result !== undefined) {\n        return result;\n      }\n\n      return next(resume, parent, result);\n    }\n\n    context.next = next;\n\n    try {\n      return next(true, this.root);\n    } catch (error) {\n      if (this.errorHandler) {\n        return this.errorHandler(error, currentContext);\n      }\n      throw error;\n    }\n  }\n}\n"],"names":["isChildRoute","parentRoute","childRoute","route","parent","hasOwnProperty","Object","prototype","cache","Map","decodeParam","val","decodeURIComponent","err","matchPath","pathname","parentKeys","parentParams","end","children","cacheKey","path","regexp","get","keys","pattern","pathToRegexp","set","m","exec","params","i","length","key","prop","name","value","undefined","call","repeat","split","delimiter","map","charAt","substr","concat","matchRoute","baseUrl","childMatches","match","childIndex","[object Object]","routeToSkip","done","childMatch","next","resolveRoute","context","action","UniversalRouterSync","routes","options","TypeError","this","errorHandler","router","root","Array","isArray","pathnameOrContext","resolve","matches","nextMatches","currentContext","resume","prevResult","lastRoute","error","Error","status","result"],"mappings":"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"}